# -*- coding: utf-8 -*-
"""KellyCriterion

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DE6N6U5w5P1wR4wSKhW5e15rkDV_1NbY
"""
#Based off tutorial from PyQuant News, Towards Data Science, and Raposa technologies
#Installs pyomo, amplpy to solve
#Installs yfinance to pull data
#Installs pandas and numpy for general use
!pip install pyomo
!pip install -q amplpy
from amplpy import AMPL, tools
ampl = tools.ampl_notebook(
    modules=["coin"], # modules to install
    license_uuid="ee26c57c-b7c3-4020-8dbb-3f69b194bf66") # license to use
import numpy as np
from pyomo.environ import *
import yfinance as yf
import pandas as pd
from datetime import date
from matplotlib import pyplot as plt

#Builds the Kelly Criterion optimization model.


def buildKCOptModel(returns: np.array, varcov: np.matrix,
                    rfr: float = 0, lam_max: float = 3):

  m = ConcreteModel()
  #This line creates an instance of a Pyomo ConcreteModel. A ConcreteModel is defined by a given set of values, which we have in this case.

  # Indices
  m.i = RangeSet(0, returns.shape[0] - 1)
  #This line creates an index for the model, by defining it as length (0, length of returns)

  # Decision variables
  # These decision variables are what we use to optimize m - our portfolio. In this case, f refers to the fractional weight of each item in the portfolio.
  # m.x refers to the leverage that each holding should have. For the PSU Quants portfolio, we will be using a leverage of 1x.
  m.f = Var(m.i, domain=Reals)
  m.x = Var(m.i, domain=Reals)

  # Parameters
  # Parameters are just things we are keying into the model - full documentation here 'https://pyomo.readthedocs.io/en/stable/pyomo_modeling_components/Parameters.html'
  m.mu = Param(m.i,
               initialize={i: m for i, m in zip(m.i, returns)})
  m.sigma = Param(m.i, m.i,
                  initialize={(i, j): varcov[i, j]
                              for i in m.i
                              for j in m.i})
  m.lam_max = lam_max

  # Constraints
  #
  @m.Constraint()
  def maxLeverageConstraint(m):
    return sum(m.x[i] for i in m.i) <= m.lam_max

  @m.Constraint(m.i)
  def posFraction(m, i):
    return m.x[i] - m.f[i] >= 0

  @m.Constraint(m.i)
  def negFraction(m, i):
    return m.x[i] + m.f[i] >= 0

  Objective
  @m.Objective(sense=maximize)
  def objective(m):
    return (rfr + sum(m.f[i] * (m.mu[i] - rfr) for i in m.i) - \
            sum(
                sum(m.f[i] * m.sigma[i, j] * m.f[j] for j in m.i)
            for i in m.i) / 2)

  return m

import yfinance as yf

class OptimalAllocation:
#rfr - 10y treasury yield
#lookback - I use 5 years
#max_leverage - set to 1, we aren't trading on leverage yet

  def __init__(self, tickers: list, max_leverage: float=1, lookback: int=1260,
               rfr: float=0.414, start: str="2000-01-01", end: str="2023-09-01",
               rebalance_freq: int=1):
    self.tickers = tickers
    self.max_leverage = max_leverage
    self.lookback = lookback
    self.start = start
    self.end = end
    self.rfr = rfr
    self.rebalance_freq = rebalance_freq
    self.data = self._getData()
    self._calcStats()

  def _getData(self):
  #pulls and cleans data
    historicals = yf.Tickers(self.tickers)
    data = historicals.history(start=self.start, end=self.end)
    data.drop(["High", "Low", "Open", "Volume", "Stock Splits", "Dividends"],
              axis=1, inplace=True)
    data.columns = data.columns.swaplevel()
    data.dropna(inplace=True)
    return data

  def _calcStats(self):
    # Calculates returns
    returns = self.data.loc[:, (slice(None), "Close")] / \
      self.data.loc[:, (slice(None), "Close")].shift(1)
    returns = returns.rename(columns={"Close": "returns"})

    means = returns.rolling(self.lookback).mean().rename(
        columns={"returns": "mean"})

    # Calculate covariance matrices, we covered this in the presentation you can find here:
    n = returns.shape[1]
    self.cov = returns.droplevel(1, axis=1).rolling(
        self.lookback).cov().values.reshape(-1, n, n)
    self.data = pd.concat([self.data, returns, means], axis=1)

  def kellyUnconstrainedAllocation(self):
    '''
    Calculates the allocation fractions for the unconstrained
    Kelly Criterion case.
    '''
    fracs = np.zeros((len(self.data), len(self.tickers)))
    fracs[:] = np.nan

    for i, (ts, row) in enumerate(self.data.iterrows()):
      if i < self.lookback:
        continue

      means = row.loc[(slice(None)), "mean"].values

      F = np.dot(means, np.linalg.inv(self.cov[i]))
      fracs[i] = F

    df_fracs = pd.DataFrame(fracs, index=self.data.index)
    midx = pd.MultiIndex.from_arrays(
        [self.tickers, len(self.tickers)*['unconstrained_fracs']])
    df_fracs.columns = midx
    return df_fracs

  def kellyHeuristicAllocation(self, kelly_level: float=.25):
    '''
    Calculates the allocation fractions using a simple max leverage heuristic
    for the Kelly Criterion.

    kelly_level: allows setting to full kelly (1) half-kelly (0.5) or any
      other multiple. This takes the solution from the QP and scales it down
      accordingly to reduce actual leverage.
    '''
    df_fracs = self.kellyUnconstrainedAllocation()
    heur_fracs = df_fracs.apply(
        lambda x: kelly_level * self.max_leverage * np.abs(x) / \
          np.abs(x).sum() * np.sign(x),
        axis=1)
    heur_fracs = heur_fracs.rename(
        columns={'unconstrained_fracs': 'heuristic_fracs'})
    return heur_fracs

  def kellyQuadProdAllocation(self, kelly_level: float=.5):
    '''
    Calculates optimal allocation fractions by solving a quadratic program
    according to the Kelly Criterion.

    kelly_level: allows setting to full kelly (1) half-kelly (0.5) or any
      other multiple. This takes the solution from the QP and scales it down
      accordingly to reduce actual leverage.
    '''
    fracs = np.zeros((len(self.data), len(self.tickers)))
    fracs[:] = np.nan
    g = fracs[:, 0].copy()

    for i, (ts, row) in enumerate(self.data.iterrows()):
      if i < self.lookback:
        continue

      means = row.loc[(slice(None)), "mean"].values
      cov = self.cov[i]
      model = buildKCOptModel(means, cov, self.rfr, self.max_leverage)
      results = SolverFactory('ipopt').solve(model)
      fracs[i] = np.array([model.f[j].value * kelly_level
                           for j in model.f])
      g[i] = model.objective.expr()

    df_fracs = pd.DataFrame(fracs, index=self.data.index)
    midx = pd.MultiIndex.from_arrays(
        [self.tickers, len(self.tickers)*['qp_fracs']])
    df_fracs.columns = midx
    return df_fracs

  def calcEqualAllocation(self):
    '''
    Rebalance so that the portfolio maintains a constant, equal allocation
    among each of the assets.
    '''
    fracs = np.ones((len(self.data), len(self.tickers))) / len(self.tickers)
    fracs[:self.lookback] = np.nan
    df_fracs = pd.DataFrame(fracs, index=self.data.index)
    midx = pd.MultiIndex.from_arrays(
        [self.tickers, len(self.tickers)*['eq_fracs']])
    df_fracs.columns = midx
    return df_fracs

opt = OptimalAllocation(['ALL', 'AMP', 'AXP', 'BRK-B', 'GS', 'JPM', 'V'])

# Calculate optimal allocations
uc_fracs = opt.kellyUnconstrainedAllocation()
heur_fracs = opt.kellyHeuristicAllocation()
qp_fracs = opt.kellyQuadProdAllocation()
eq_fracs = opt.calcEqualAllocation()

colors = plt.rcParams['axes.prop_cycle'].by_key()['color']
labels = opt.tickers

fig, ax = plt.subplots(3, figsize=(12, 8), sharex=True)
ax[0].axis('off')
ax[2].axis('off')

print(heur_fracs.tail(1))

ax[1].plot(heur_fracs * 100)
ax[1].set_ylabel('Portfolio Allocation (%)')
ax[1].set_title('Heuristic Allocation')



plt.tight_layout()
plt.show()
